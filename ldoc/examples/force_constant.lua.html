<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>flos documentation</title>
    <link rel="stylesheet" href="../ldoc_fixed.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>flos</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>



<h2>Examples</h2>
<ul class="nowrap">
  <li><a href="../examples/add_force.lua.html">add_force.lua</a></li>
  <li><a href="../examples/conv_meshcutoff.lua.html">conv_meshcutoff.lua</a></li>
  <li><strong>force_constant.lua</strong></li>
  <li><a href="../examples/neb_simple.lua.html">neb_simple.lua</a></li>
  <li><a href="../examples/relax_cell.lua.html">relax_cell.lua</a></li>
  <li><a href="../examples/relax_cell_geometry.lua.html">relax_cell_geometry.lua</a></li>
  <li><a href="../examples/relax_geometry_cg.lua.html">relax_geometry_cg.lua</a></li>
  <li><a href="../examples/relax_geometry_fire.lua.html">relax_geometry_fire.lua</a></li>
  <li><a href="../examples/relax_geometry_lbfgs.lua.html">relax_geometry_lbfgs.lua</a></li>
</ul>
<h2>Modules</h2>
<ul class="nowrap">
  <li><a href="../modules/error.html">error</a></li>
  <li><a href="../modules/Linear.html">Linear</a></li>
  <li><a href="../modules/Tables.html">Tables</a></li>
</ul>
<h2>Classes</h2>
<ul class="nowrap">
  <li><a href="../classes/MDStep.html">MDStep</a></li>
  <li><a href="../classes/Array.html">Array</a></li>
  <li><a href="../classes/Shape.html">Shape</a></li>
  <li><a href="../classes/Optimizer.html">Optimizer</a></li>
  <li><a href="../classes/CG.html">CG</a></li>
  <li><a href="../classes/FIRE.html">FIRE</a></li>
  <li><a href="../classes/LBFGS.html">LBFGS</a></li>
  <li><a href="../classes/Line.html">Line</a></li>
  <li><a href="../classes/NEB.html">NEB</a></li>
</ul>
<h2>Manual</h2>
<ul class="nowrap">
  <li><a href="../manual/README.md.html">README</a></li>
</ul>

</div>

<div id="content">

    <h2>force_constant.lua</h2>
<pre>
<span class="comment">--[[
Example on how to run a custom force constant run using flos.

This example reads the input options as read by
SIESTA and defines the FC type of run:

 - MD.FCFirst
 - MD.FCLast
 - MD.FCDispl (max-displacement, i.e. for the heaviest atom)

This script will emulate the FC run built-in SIESTA and will only
create the DM file for the first (x0) coordinate.

There are a couple of parameters:

1. same_displ = true|false
 if true all displacements will be true, and the algorithm is equivalent
 to the SIESTA FC run.
 If false, the displacements are dependent on the relative masses of the
 atomic species. The given displacement is then the maximum displacement,
 i.e. the displacement on the heaviest atom.
2. displ = {}
 a list of different displacements. If one is interested in several different
 force constant runs with different displacements, this is a simple way
 to do it all at once.

--]]</span>

<span class="comment">-- Set this flag to false if the displacements should be
</span><span class="comment">-- different for atoms with different masses.
</span><span class="keyword">local</span> same_displ = <span class="keyword">true</span>

<span class="comment">-- In case you want to run several FC runs using different
</span><span class="comment">-- displacements in a single run you may use this list.
</span><span class="keyword">local</span> displ = {<span class="number">0.005</span>, <span class="number">0.01</span>, <span class="number">0.02</span>, <span class="number">0.03</span>, <span class="number">0.04</span>}
<span class="comment">-- To get the displacement from SIESTA, uncomment the following line.
</span><span class="comment">-- local displ = nil
</span>


<span class="comment">-- Everything below this point should not be touched.
</span>
<span class="comment">-- Load the FLOS module
</span><span class="keyword">local</span> flos = <span class="global">require</span> <span class="string">"flos"</span>

<span class="comment">-- Starting displacement
</span><span class="keyword">local</span> idispl = <span class="number">1</span>

<span class="comment">-- Create placeholder for the FC object
</span><span class="comment">-- This will be allocated in the initialization routine
</span><span class="keyword">local</span> FC = <span class="keyword">nil</span>

<span class="comment">-- Grab the unit table of siesta (it is already created
</span><span class="comment">-- by SIESTA)
</span><span class="keyword">local</span> Unit = siesta.Units


<span class="keyword">function</span> siesta_comm()

   <span class="comment">-- This routine does exchange of data with SIESTA
</span>   <span class="keyword">local</span> ret_tbl = {}

   <span class="comment">-- Do the actual communication with SIESTA
</span>   <span class="keyword">if</span> siesta.state == siesta.INITIALIZE <span class="keyword">then</span>

      <span class="comment">-- In the initialization step we request the
</span>      <span class="comment">-- convergence criteria
</span>      <span class="comment">--  MD.FCFirst
</span>      <span class="comment">--  MD.FCLast
</span>      <span class="comment">--  MD.FCDispl
</span>      siesta.receive({<span class="string">"geom.xa"</span>,
		      <span class="string">"geom.mass"</span>,
		      <span class="string">"MD.FC.Displ"</span>,
		      <span class="string">"MD.FC.First"</span>,
		      <span class="string">"MD.FC.Last"</span>})

      <span class="comment">-- Print information
</span>      IOprint(<span class="string">"\nLUA Using the FC run"</span>)

      <span class="keyword">if</span> displ == <span class="keyword">nil</span> <span class="keyword">then</span>
	 <span class="comment">-- Specify the displacement if the user requests
</span>	 <span class="comment">-- the information from SIESTA
</span>	 displ = { siesta.MD.FC.Displ / Unit.Ang }
      <span class="keyword">end</span>

      <span class="comment">-- Get coordinates in Ang
</span>      <span class="keyword">local</span> xa = flos.Array.from(siesta.geom.xa) / Unit.Ang

      indices = flos.Array.range(siesta.MD.FC.First, siesta.MD.FC.Last)
      <span class="keyword">if</span> same_displ <span class="keyword">then</span>
	 <span class="comment">-- No masses, all equal (implicitly)
</span>	 FC = flos.ForceHessian(xa, indices, displ[idispl])
      <span class="keyword">else</span>
	 <span class="comment">-- Masses used
</span>	 FC = flos.ForceHessian(xa, indices, displ[idispl],
				siesta.geom.mass)
      <span class="keyword">end</span>

   <span class="keyword">end</span>

   <span class="keyword">if</span> siesta.state == siesta.MOVE <span class="keyword">then</span>

      <span class="comment">-- We retrieve the current coordinates, the forces
</span>      <span class="comment">-- and whether the geometry has relaxed
</span>      siesta.receive({<span class="string">"geom.xa"</span>,
		      <span class="string">"geom.fa"</span>,
		      <span class="string">"Write.DM"</span>,
		      <span class="string">"Write.EndOfCycle.DM"</span>,
		      <span class="string">"MD.Relaxed"</span>})

      ret_tbl = siesta_move(siesta)

      <span class="comment">-- Disable writing the DM after the initial DM creation
</span>      <span class="comment">-- (forces the reuse of the xa0 DM)
</span>      siesta.Write.DM = <span class="keyword">false</span>
      ret_tbl[#ret_tbl+<span class="number">1</span>] = <span class="string">"Write.DM"</span>
      siesta.Write.EndOfCycle.DM = <span class="keyword">false</span>
      ret_tbl[#ret_tbl+<span class="number">1</span>] = <span class="string">"Write.EndOfCycle.DM"</span>

      <span class="comment">-- write to the FC file (this will get updated periodically to
</span>      <span class="comment">-- track information).
</span>      <span class="comment">-- The files also contain the displacements.
</span>      FC:save( (<span class="string">"FLOS.FC.%d"</span>):format(idispl) )
      FC:save( (<span class="string">"FLOS.FCSYM.%d"</span>):format(idispl), <span class="keyword">true</span> )

      <span class="keyword">if</span> siesta.MD.Relaxed <span class="keyword">then</span>
	 <span class="comment">-- Check that we should move to the next displacement
</span>	 <span class="comment">-- iteration
</span>	 idispl = idispl + <span class="number">1</span>

	 <span class="keyword">if</span> idispl &lt;= #displ <span class="keyword">then</span>

	    <span class="comment">-- Reset counters for the next FC run with
</span>	    <span class="comment">-- different displacement
</span>	    FC:reset()
	    <span class="comment">-- Update new displacement
</span>	    FC:set_displacement(displ[idispl])

	    <span class="comment">-- Set for the next displacement (no need
</span>	    <span class="comment">-- to re-calculate the initial forces)
</span>	    siesta.geom.xa = FC:<span class="global">next</span>() * Unit.Ang
	    siesta.MD.Relaxed = <span class="keyword">false</span>

	 <span class="keyword">end</span>

      <span class="keyword">end</span>

   <span class="keyword">end</span>

   siesta.send(ret_tbl)
<span class="keyword">end</span>

<span class="keyword">function</span> siesta_move(siesta)

   <span class="keyword">local</span> fa = flos.Array.from(siesta.geom.fa) * Unit.Ang / Unit.eV

   <span class="comment">-- Send back new coordinates (convert to Bohr)
</span>   siesta.geom.xa = FC:<span class="global">next</span>(fa) * Unit.Ang
   siesta.MD.Relaxed = FC:done()

   <span class="keyword">return</span> {<span class="string">"geom.xa"</span>,
	   <span class="string">"MD.Relaxed"</span>}
<span class="keyword">end</span></pre>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2019-05-23 08:32:22 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
