<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>flos documentation</title>
    <link rel="stylesheet" href="../ldoc_fixed.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>flos</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>



<h2>Examples</h2>
<ul class="nowrap">
  <li><a href="../examples/add_force.lua.html">add_force.lua</a></li>
  <li><a href="../examples/conv_meshcutoff.lua.html">conv_meshcutoff.lua</a></li>
  <li><a href="../examples/force_constant.lua.html">force_constant.lua</a></li>
  <li><a href="../examples/neb_simple.lua.html">neb_simple.lua</a></li>
  <li><a href="../examples/relax_cell.lua.html">relax_cell.lua</a></li>
  <li><strong>relax_cell_geometry.lua</strong></li>
  <li><a href="../examples/relax_geometry_cg.lua.html">relax_geometry_cg.lua</a></li>
  <li><a href="../examples/relax_geometry_fire.lua.html">relax_geometry_fire.lua</a></li>
  <li><a href="../examples/relax_geometry_lbfgs.lua.html">relax_geometry_lbfgs.lua</a></li>
</ul>
<h2>Modules</h2>
<ul class="nowrap">
  <li><a href="../modules/error.html">error</a></li>
  <li><a href="../modules/Linear.html">Linear</a></li>
  <li><a href="../modules/Tables.html">Tables</a></li>
</ul>
<h2>Classes</h2>
<ul class="nowrap">
  <li><a href="../classes/MDStep.html">MDStep</a></li>
  <li><a href="../classes/Array.html">Array</a></li>
  <li><a href="../classes/Shape.html">Shape</a></li>
  <li><a href="../classes/Optimizer.html">Optimizer</a></li>
  <li><a href="../classes/CG.html">CG</a></li>
  <li><a href="../classes/FIRE.html">FIRE</a></li>
  <li><a href="../classes/LBFGS.html">LBFGS</a></li>
  <li><a href="../classes/Line.html">Line</a></li>
  <li><a href="../classes/NEB.html">NEB</a></li>
</ul>
<h2>Manual</h2>
<ul class="nowrap">
  <li><a href="../manual/README.md.html">README</a></li>
</ul>

</div>

<div id="content">

    <h2>relax_cell_geometry.lua</h2>
<pre>
<span class="comment">--[[
Example on how to relax lattice vectors using the LBFGS
algorithm.

This example can take any geometry and will relax the
cell vectors according to the siesta input options:

 - MD.MaxForceTol
 - MD.MaxStressTol
 - MD.MaxCGDispl

This example is prepared to easily create
a combined relaxation of several LBFGS algorithms
simultaneously. In some cases this is shown to
speed up the convergence because an average is taken
over several optimizations.

To converge using several LBFGS algorithms simultaneously
may be understood phenomenologically by a "line-search"
optimization by weighing two Hessian optimizations.

This example defaults to two simultaneous LBFGS algorithms
which seems adequate in most situations.

--]]</span>

<span class="comment">-- Load the FLOS module
</span><span class="keyword">local</span> flos = <span class="global">require</span> <span class="string">"flos"</span>

<span class="comment">-- Create the two LBFGS algorithms with
</span><span class="comment">-- initial Hessians 1/75 and 1/50
</span><span class="keyword">local</span> geom = {}
geom[<span class="number">1</span>] = flos.LBFGS{H0 = <span class="number">1.</span> / <span class="number">75.</span>}
geom[<span class="number">2</span>] = flos.LBFGS{H0 = <span class="number">1.</span> / <span class="number">50.</span>}

<span class="keyword">local</span> lattice = {}
lattice[<span class="number">1</span>] = flos.LBFGS{H0 = <span class="number">1.</span> / <span class="number">75.</span>}
lattice[<span class="number">2</span>] = flos.LBFGS{H0 = <span class="number">1.</span> / <span class="number">50.</span>}

<span class="comment">-- Grab the unit table of siesta (it is already created
</span><span class="comment">-- by SIESTA)
</span><span class="keyword">local</span> Unit = siesta.Units

<span class="comment">-- Initial strain that we want to optimize to minimize
</span><span class="comment">-- the stress.
</span><span class="keyword">local</span> strain = flos.Array.zeros(<span class="number">6</span>)
<span class="comment">-- Mask which directions we should relax
</span><span class="comment">--   [xx, yy, zz, yz, xz, xy]
</span><span class="comment">-- Default to all.
</span><span class="keyword">local</span> stress_mask = flos.Array.ones(<span class="number">6</span>)

<span class="comment">-- To only relax the diagonal elements you may do this:
</span>stress_mask[<span class="number">4</span>] = <span class="number">0.</span>
stress_mask[<span class="number">5</span>] = <span class="number">0.</span>
stress_mask[<span class="number">6</span>] = <span class="number">0.</span>

<span class="comment">-- The initial cell
</span><span class="keyword">local</span> cell_first

<span class="comment">-- This variable controls which relaxation is performed
</span><span class="comment">-- first.
</span><span class="comment">-- If true, it starts by relaxing the geometry (coordinates)
</span><span class="comment">--    (recommended)
</span><span class="comment">-- If false, it starts by relaxing the cell vectors.
</span><span class="keyword">local</span> relax_geom = <span class="keyword">true</span>

<span class="keyword">function</span> siesta_comm()

   <span class="comment">-- This routine does exchange of data with SIESTA
</span>   <span class="keyword">local</span> ret_tbl = {}

   <span class="comment">-- Do the actual communication with SIESTA
</span>   <span class="keyword">if</span> siesta.state == siesta.INITIALIZE <span class="keyword">then</span>

      <span class="comment">-- In the initialization step we request the
</span>      <span class="comment">-- convergence criteria
</span>      <span class="comment">--  MD.MaxDispl
</span>      <span class="comment">--  MD.MaxStressTol
</span>      siesta.receive({<span class="string">"geom.cell"</span>,
		      <span class="string">"MD.Relax.Cell"</span>,
		      <span class="string">"MD.MaxDispl"</span>,
		      <span class="string">"MD.MaxForceTol"</span>,
		      <span class="string">"MD.MaxStressTol"</span>})

      <span class="comment">-- Check that we are allowed to change the cell parameters
</span>      <span class="keyword">if</span> <span class="keyword">not</span> siesta.MD.Relax.Cell <span class="keyword">then</span>

	 <span class="comment">-- We force SIESTA to relax the cell vectors
</span>	 siesta.MD.Relax.Cell = <span class="keyword">true</span>
	 ret_tbl = {<span class="string">"MD.Relax.Cell"</span>}

      <span class="keyword">end</span>

      <span class="comment">-- Print information
</span>      IOprint(<span class="string">"\nLUA convergence information for the LBFGS algorithms:"</span>)

      <span class="comment">-- Store the initial cell (global variable)
</span>      cell_first = flos.Array.from(siesta.geom.cell) / Unit.Ang

      <span class="comment">-- Ensure we update the convergence criteria
</span>      <span class="comment">-- from SIESTA (in this way one can ensure siesta options)
</span>      IOprint(<span class="string">"Lattice optimization:"</span>)
      <span class="keyword">for</span> i = <span class="number">1</span>, #lattice <span class="keyword">do</span>
	 lattice[i].tolerance = siesta.MD.MaxStressTol * Unit.Ang ^ <span class="number">3</span> / Unit.eV
	 lattice[i].max_dF = siesta.MD.MaxDispl / Unit.Ang

	 <span class="comment">-- Print information
</span>	 <span class="keyword">if</span> siesta.IONode <span class="keyword">then</span>
	    lattice[i]:info()
	 <span class="keyword">end</span>
      <span class="keyword">end</span>

      IOprint(<span class="string">"\nGeometry optimization:"</span>)
      <span class="keyword">for</span> i = <span class="number">1</span>, #geom <span class="keyword">do</span>
	 geom[i].tolerance = siesta.MD.MaxForceTol * Unit.Ang / Unit.eV
	 geom[i].max_dF = siesta.MD.MaxDispl / Unit.Ang

	 <span class="comment">-- Print information
</span>	 <span class="keyword">if</span> siesta.IONode <span class="keyword">then</span>
	    geom[i]:info()
	 <span class="keyword">end</span>
      <span class="keyword">end</span>

      <span class="keyword">if</span> relax_geom <span class="keyword">then</span>
	 IOprint(<span class="string">"\nLUA: Starting with geometry relaxation!\n"</span>)
      <span class="keyword">else</span>
	 IOprint(<span class="string">"\nLUA: Starting with cell relaxation!\n"</span>)
      <span class="keyword">end</span>

   <span class="keyword">end</span>

   <span class="keyword">if</span> siesta.state == siesta.MOVE <span class="keyword">then</span>

      <span class="comment">-- Regardless of the method we
</span>      <span class="comment">-- retrieve everything so that we
</span>      <span class="comment">-- can check if both are converged
</span>      siesta.receive({<span class="string">"geom.cell"</span>,
		      <span class="string">"geom.xa"</span>,
		      <span class="string">"geom.fa"</span>,
		      <span class="string">"geom.stress"</span>,
		      <span class="string">"MD.Relaxed"</span>})
      ret_tbl = siesta_move(siesta)
   <span class="keyword">end</span>

   siesta.send(ret_tbl)
<span class="keyword">end</span>

<span class="keyword">function</span> siesta_move(siesta)
   <span class="comment">-- Dispatcher function for doing both geometry and lattice
</span>   <span class="comment">-- relaxation.
</span>
   <span class="comment">-- Internally convert the siesta quantities
</span>   <span class="comment">-- to their correct physical values
</span>   siesta.geom.cell = flos.Array.from(siesta.geom.cell) / Unit.Ang
   siesta.geom.xa = flos.Array.from(siesta.geom.xa) / Unit.Ang
   siesta.geom.fa = flos.Array.from(siesta.geom.fa) * Unit.Ang / Unit.eV
   <span class="comment">-- The stress is the negative gradient
</span>   siesta.geom.stress = -flos.Array.from(siesta.geom.stress) * Unit.Ang ^ <span class="number">3</span> / Unit.eV


   <span class="comment">-- Grab whether both methods have converged
</span>   <span class="keyword">local</span> voigt = stress_to_voigt(siesta.geom.stress)
   voigt = voigt * stress_mask
   <span class="keyword">local</span> conv_lattice = lattice[<span class="number">1</span>]:optimized(voigt)
   voigt = <span class="keyword">nil</span>

   <span class="keyword">local</span> conv_geom = geom[<span class="number">1</span>]:optimized(siesta.geom.fa)

   <span class="comment">-- Immediately return if both have converged
</span>   <span class="keyword">if</span> conv_lattice <span class="keyword">and</span> conv_geom <span class="keyword">then</span>

      siesta.MD.Relaxed = <span class="keyword">true</span>
      <span class="keyword">return</span> {<span class="string">'MD.Relaxed'</span>}

   <span class="keyword">end</span>

   <span class="comment">-- We have not converged
</span>   <span class="comment">-- Figure out if we should switch algorithm
</span>   <span class="keyword">if</span> relax_geom <span class="keyword">and</span> conv_geom <span class="keyword">then</span>

      relax_geom = <span class="keyword">false</span>
      <span class="comment">-- Ensure that we reset the geometry relaxation
</span>      <span class="keyword">for</span> i = <span class="number">1</span>, #geom <span class="keyword">do</span>
	 geom[i]:reset()
      <span class="keyword">end</span>

      <span class="comment">-- Update the initial cell as the algorithm
</span>      <span class="comment">-- has started from a fresh (it is already
</span>      <span class="comment">-- in correct units).
</span>      cell_first = siesta.geom.cell:copy()
      <span class="comment">-- Also initialize the initial strain
</span>      strain = flos.Array.zeros(<span class="number">6</span>)

      IOprint(<span class="string">"\nLUA: switching to cell relaxation!\n"</span>)

   <span class="keyword">elseif</span> (<span class="keyword">not</span> relax_geom) <span class="keyword">and</span> conv_lattice <span class="keyword">then</span>

      relax_geom = <span class="keyword">true</span>
      <span class="comment">-- Ensure that we reset the geometry relaxation
</span>      <span class="keyword">for</span> i = <span class="number">1</span>, #lattice <span class="keyword">do</span>
	 lattice[i]:reset()
      <span class="keyword">end</span>

      IOprint(<span class="string">"\nLUA: switching to geometry relaxation!\n"</span>)

   <span class="keyword">end</span>

   <span class="comment">-- Now perform the optimization of the method
</span>   <span class="comment">-- we currently use
</span>   <span class="keyword">if</span> relax_geom <span class="keyword">then</span>
      <span class="keyword">return</span> siesta_geometry(siesta)
   <span class="keyword">else</span>
      <span class="keyword">return</span> siesta_cell(siesta)
   <span class="keyword">end</span>

<span class="keyword">end</span>


<span class="keyword">function</span> stress_to_voigt(stress)
   <span class="comment">-- Retrieve the stress
</span>   <span class="keyword">local</span> voigt = flos.Array.empty(<span class="number">6</span>)

   <span class="comment">-- Copy over the stress to the Voigt representation
</span>   voigt[<span class="number">1</span>] = stress[<span class="number">1</span>][<span class="number">1</span>]
   voigt[<span class="number">2</span>] = stress[<span class="number">2</span>][<span class="number">2</span>]
   voigt[<span class="number">3</span>] = stress[<span class="number">3</span>][<span class="number">3</span>]
   <span class="comment">-- ... symmetrize stress tensor
</span>   voigt[<span class="number">4</span>] = (stress[<span class="number">2</span>][<span class="number">3</span>] + stress[<span class="number">3</span>][<span class="number">2</span>]) * <span class="number">0.5</span>
   voigt[<span class="number">5</span>] = (stress[<span class="number">1</span>][<span class="number">3</span>] + stress[<span class="number">3</span>][<span class="number">1</span>]) * <span class="number">0.5</span>
   voigt[<span class="number">6</span>] = (stress[<span class="number">1</span>][<span class="number">2</span>] + stress[<span class="number">2</span>][<span class="number">1</span>]) * <span class="number">0.5</span>

   <span class="keyword">return</span> voigt
<span class="keyword">end</span>

<span class="keyword">function</span> stress_from_voigt(voigt)
   <span class="keyword">local</span> stress = flos.Array.empty(<span class="number">3</span>, <span class="number">3</span>)

   <span class="comment">-- Copy over the stress from Voigt representation
</span>   stress[<span class="number">1</span>][<span class="number">1</span>] = voigt[<span class="number">1</span>]
   stress[<span class="number">1</span>][<span class="number">2</span>] = voigt[<span class="number">6</span>]
   stress[<span class="number">1</span>][<span class="number">3</span>] = voigt[<span class="number">5</span>]
   stress[<span class="number">2</span>][<span class="number">1</span>] = voigt[<span class="number">6</span>]
   stress[<span class="number">2</span>][<span class="number">2</span>] = voigt[<span class="number">2</span>]
   stress[<span class="number">2</span>][<span class="number">3</span>] = voigt[<span class="number">4</span>]
   stress[<span class="number">3</span>][<span class="number">1</span>] = voigt[<span class="number">5</span>]
   stress[<span class="number">3</span>][<span class="number">2</span>] = voigt[<span class="number">4</span>]
   stress[<span class="number">3</span>][<span class="number">3</span>] = voigt[<span class="number">3</span>]

   <span class="keyword">return</span> stress
<span class="keyword">end</span>


<span class="keyword">function</span> siesta_geometry(siesta)

   <span class="comment">-- Retrieve the atomic coordinates and the forces
</span>   <span class="keyword">local</span> xa = siesta.geom.xa
   <span class="comment">-- Note the LBFGS requires the gradient, and
</span>   <span class="comment">-- the force is the negative gradient.
</span>   <span class="keyword">local</span> fa = siesta.geom.fa

   <span class="comment">-- Perform step (initialize arrays to do averaging if more
</span>   <span class="comment">-- LBFGS algorithms are in use).
</span>   <span class="keyword">local</span> all_xa = {}
   <span class="keyword">local</span> weight = flos.Array.empty(#geom)
   <span class="keyword">for</span> i = <span class="number">1</span>, #geom <span class="keyword">do</span>

      <span class="comment">-- Calculate the next optimized structure (that
</span>      <span class="comment">-- minimizes the Hessian)
</span>      all_xa[i] = geom[i]:optimize(xa, fa)

      <span class="comment">-- Get the optimization length for calculating
</span>      <span class="comment">-- the best average.
</span>      weight[i] = geom[i].weight

   <span class="keyword">end</span>

   <span class="comment">-- Normalize weight
</span>   weight = weight / weight:sum()
   <span class="keyword">if</span> #geom &gt; <span class="number">1</span> <span class="keyword">then</span>
      IOprint(<span class="string">"\nGeometry weighted average: "</span>, weight)
   <span class="keyword">end</span>

   <span class="comment">-- Calculate the new coordinates and figure out
</span>   <span class="comment">-- if the algorithms has been optimized.
</span>   <span class="keyword">local</span> out_xa = all_xa[<span class="number">1</span>] * weight[<span class="number">1</span>]
   <span class="keyword">for</span> i = <span class="number">2</span>, #geom <span class="keyword">do</span>
      out_xa = out_xa + all_xa[i] * weight[i]
   <span class="keyword">end</span>
   <span class="comment">-- Immediately clean-up to reduce memory overhead (force GC)
</span>   all_xa = <span class="keyword">nil</span>

   <span class="comment">-- Send back new coordinates (convert to Bohr)
</span>   siesta.geom.xa = out_xa * Unit.Ang

   <span class="keyword">return</span> {<span class="string">"geom.xa"</span>}
<span class="keyword">end</span>


<span class="keyword">function</span> siesta_cell(siesta)

   <span class="comment">-- Get the current cell
</span>   <span class="keyword">local</span> cell = siesta.geom.cell
   <span class="comment">-- Retrieve the atomic coordinates
</span>   <span class="keyword">local</span> xa = siesta.geom.xa
   <span class="comment">-- Retrieve the stress
</span>   <span class="keyword">local</span> stress = stress_to_voigt(siesta.geom.stress)
   stress = stress * stress_mask

   <span class="comment">-- Calculate the volume of the cell to normalize the stress
</span>   <span class="keyword">local</span> vol = cell[<span class="number">1</span>]:cross(cell[<span class="number">2</span>]):dot(cell[<span class="number">3</span>])

   <span class="comment">-- Perform step (initialize arrays to do averaging if more
</span>   <span class="comment">-- LBFGS algorithms are in use).
</span>   <span class="keyword">local</span> all_strain = {}
   <span class="keyword">local</span> weight = flos.Array.empty(#lattice)
   <span class="keyword">for</span> i = <span class="number">1</span>, #lattice <span class="keyword">do</span>

      <span class="comment">-- Calculate the next optimized cell structure (that
</span>      <span class="comment">-- minimizes the Hessian)
</span>      <span class="comment">-- The optimization routine requires the stress to be per cell
</span>      all_strain[i] = lattice[i]:optimize(strain, stress * vol)

      <span class="comment">-- The LBFGS algorithms updates the internal optimized
</span>      <span class="comment">-- variable based on stress * vol (eV / cell)
</span>      <span class="comment">-- However, we are relaxing the stress in (eV / Ang^3)
</span>      <span class="comment">-- So force the optimization to be estimated on the
</span>      <span class="comment">-- correct units.
</span>      <span class="comment">-- Secondly, the stress optimization is per element
</span>      <span class="comment">-- so we need to flatten the stress
</span>      lattice[i]:optimized(stress)

      <span class="comment">-- Get the optimization length for calculating
</span>      <span class="comment">-- the best average.
</span>      weight[i] = lattice[i].weight

   <span class="keyword">end</span>

   <span class="comment">-- Normalize weight
</span>   weight = weight / weight:sum()
   <span class="keyword">if</span> #lattice &gt; <span class="number">1</span> <span class="keyword">then</span>
      IOprint(<span class="string">"\nLattice weighted average: "</span>, weight)
   <span class="keyword">end</span>

   <span class="comment">-- Calculate the new optimized strain that should
</span>   <span class="comment">-- be applied to the cell vectors to minimize the stress.
</span>   <span class="comment">-- Also track if we have converged (stress &lt; min-stress)
</span>   <span class="keyword">local</span> out_strain = all_strain[<span class="number">1</span>] * weight[<span class="number">1</span>]
   <span class="keyword">for</span> i = <span class="number">2</span>, #lattice <span class="keyword">do</span>
      out_strain = out_strain + all_strain[i] * weight[i]
   <span class="keyword">end</span>
   <span class="comment">-- Immediately clean-up to reduce memory overhead (force GC)
</span>   all_strain = <span class="keyword">nil</span>

   <span class="comment">-- Apply mask to ensure only relaxation of cell-vectors
</span>   <span class="comment">-- along wanted directions.
</span>   strain = out_strain * stress_mask
   out_strain = <span class="keyword">nil</span>

   <span class="comment">-- Calculate the new cell
</span>   <span class="comment">-- Note that we add one in the diagonal
</span>   <span class="comment">-- to create the summed cell
</span>   <span class="keyword">local</span> dcell = flos.Array( cell.shape )
   dcell[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1.0</span> + strain[<span class="number">1</span>]
   dcell[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0.5</span> * strain[<span class="number">6</span>]
   dcell[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">0.5</span> * strain[<span class="number">5</span>]
   dcell[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0.5</span> * strain[<span class="number">6</span>]
   dcell[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1.0</span> + strain[<span class="number">2</span>]
   dcell[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">0.5</span> * strain[<span class="number">4</span>]
   dcell[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">0.5</span> * strain[<span class="number">5</span>]
   dcell[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">0.5</span> * strain[<span class="number">4</span>]
   dcell[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1.0</span> + strain[<span class="number">3</span>]

   <span class="comment">-- Create the new cell...
</span>   <span class="comment">-- As the strain is a continuously updated value
</span>   <span class="comment">-- we need to retain the original cell (done
</span>   <span class="comment">-- above in the siesta.INITIALIZE step).
</span>   <span class="keyword">local</span> out_cell = cell_first:dot(dcell)
   dcell = <span class="keyword">nil</span>

   <span class="comment">-- Calculate the new scaled coordinates
</span>   <span class="comment">-- First get the fractional coordinates in the
</span>   <span class="comment">-- previous cell.
</span>   <span class="keyword">local</span> lat = flos.Lattice:new(cell)
   <span class="keyword">local</span> fxa = lat:fractional(xa)
   <span class="comment">-- Then convert the coordinates to the
</span>   <span class="comment">-- new cell coordinates by simple scaling.
</span>   xa = fxa:dot(out_cell)
   lat = <span class="keyword">nil</span>
   fxa = <span class="keyword">nil</span>

   <span class="comment">-- Send back new coordinates (convert to Bohr)
</span>   siesta.geom.cell = out_cell * Unit.Ang
   siesta.geom.xa = xa * Unit.Ang

   <span class="keyword">return</span> {<span class="string">"geom.cell"</span>,
	   <span class="string">"geom.xa"</span>}
<span class="keyword">end</span></pre>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2019-05-23 08:36:38 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
